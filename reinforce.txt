-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reinforcement learning in Haskell
--   
--   See <a>README.md</a>. <tt>reinforce</tt> is a library which exports an
--   OpenAI-gym-like typeclass, <tt>MonadEnv</tt>, with both an interface
--   to the <a>gym-http-api</a>, as well as haskell-native environments
--   which provide a substantial speed-up to the http-server interface.
--   This is an environment-first library, with basic reinforcment learning
--   algorithms being developed on branches in subpackages (see
--   <a>Development and Milestones</a>). <tt>reinforce</tt> is currently an
--   "alpha" release since it still needs some work defining some formal
--   structures around what state-spaces and action-spaces should look
--   like, however haskell's typesystem is expressive enough that this
--   seems to be more of a "nice-to-have." It's in active development and
--   has some beginner-friendly contributions - from porting new gym
--   environments to implementing new algorithms.
@package reinforce
@version 0.0.0.1


-- | Re-exports of common functions and newer functions
module Reinforce.Prelude

-- | A monadic while loop
whileM_ :: forall m a. Monad m => m Bool -> m a -> m ()

-- | a safer <tt>head</tt> with something safer
head :: [a] -> Maybe a

-- | Prelude's <tt>head</tt> - for capatability.
unsafeHead :: [a] -> a


module Reinforce.Spaces.State

-- | State space information to convert to and from a Data.Vector
class StateSpace s
toVector :: StateSpace s => s -> Vector Double
fromVector :: (StateSpace s, MonadThrow m) => Vector Double -> m s

-- | State space information to convert to and from a static hmatrix vector
class StateSpaceStatic s where type Size s :: Nat where {
    type family Size s :: Nat;
}
toR :: StateSpaceStatic s => s -> R (Size s)
instance Reinforce.Spaces.State.StateSpaceStatic ()
instance Reinforce.Spaces.State.StateSpace (Data.Vector.Vector GHC.Types.Double)
instance GHC.Real.Integral n => Reinforce.Spaces.State.StateSpace (Data.Vector.Vector n)
instance Reinforce.Spaces.State.StateSpace [GHC.Types.Float]


-- | User-facing API for MonadEnv, typeclass used to implement an
--   environment
module Control.MonadEnv

-- | The environment monad TODO: Think about two typeclasses:
--   ContinuousMonadEnv and EpisodicMonadEnv
class (Num r, Monad e) => MonadEnv e s a r | e -> s a r

-- | Any environment must be initialized with <a>reset</a>. This can be
--   used to reset the environment at any time. It's expected that
--   resetting an environment begins a new episode (and can only be called
--   once in a continuous environment).
reset :: MonadEnv e s a r => e (Initial s)

-- | Step though an environment with an action, run the action in the
--   environment, and return a reward and the new state of the environment.
step :: MonadEnv e s a r => a -> e (Obs r s)

-- | An observation of the environment will either show that the
--   environment is done with the episode (yielding <a>Done</a>), that the
--   environment has already <a>Terminated</a>, or will return the reward
--   of the last action performed and the next state TODO: return
--   <tt>Terminal</tt> (or return ()) on failure
data Obs r o
Next :: !r -> !o -> Obs r o
Done :: !r -> !(Maybe o) -> Obs r o
Terminated :: Obs r o

-- | When starting an episode, we want to send an indication that the
--   environment is starting without conflating this type with future steps
--   (in <tt>Obs r o</tt>)
data Initial o
Initial :: !o -> Initial o
EmptyEpisode :: Initial o

-- | A concrete reward signal.
type Reward = Double
instance (GHC.Classes.Eq o, GHC.Classes.Eq r) => GHC.Classes.Eq (Control.MonadEnv.Obs r o)
instance (GHC.Show.Show o, GHC.Show.Show r) => GHC.Show.Show (Control.MonadEnv.Obs r o)
instance Control.MonadEnv.MonadEnv e s a r => Control.MonadEnv.MonadEnv (Control.Monad.Trans.Reader.ReaderT t e) s a r
instance Control.MonadEnv.MonadEnv e s a r => Control.MonadEnv.MonadEnv (Control.Monad.Trans.State.Lazy.StateT t e) s a r
instance (GHC.Base.Monoid t, Control.MonadEnv.MonadEnv e s a r) => Control.MonadEnv.MonadEnv (Control.Monad.Trans.Writer.Strict.WriterT t e) s a r
instance (GHC.Base.Monoid writer, Control.MonadEnv.MonadEnv e s a r) => Control.MonadEnv.MonadEnv (Control.Monad.Trans.RWS.Strict.RWST reader writer state e) s a r


-- | typeclass to remove extraneous mwc-random functions
module Control.MonadMWCRandom

-- | MonadMWCRandom for public use. FIXME: use with PrimState so that we
--   can use ST
class Monad m => MonadMWCRandom m
getGen :: MonadMWCRandom m => m GenIO

-- | A convenience type constraint with MonadMWCRandom and MonadIO.
type MonadMWCRandomIO m = (MonadIO m, MonadMWCRandom m)

-- | simple type alias for transformer-less variant
type MWCRand = MWCRandT Identity

-- | a wrapper to share a generator without using reader
newtype MWCRandT m a
MWCRandT :: ReaderT GenIO m a -> MWCRandT m a
[getMWCRandT] :: MWCRandT m a -> ReaderT GenIO m a

-- | run a transformerless MWC-random Monad
runMWCRand :: MWCRand a -> GenIO -> a

-- | unwrap MonadMWCRandom
runMWCRandT :: MWCRandT m a -> GenIO -> m a

-- | A shorter name for PRNG state in the <a>IO</a> monad.
type GenIO = Gen (PrimState IO)

-- | uniform referencing MonadMWCRandom's generator
uniform :: (MonadIO m, MonadMWCRandom m, Variate a) => m a

-- | uniformR referencing MonadMWCRandom's generator
uniformR :: (MonadIO m, MonadMWCRandom m, Variate a) => (a, a) -> m a

-- | genContVar referencing MonadMWCRandom's generator
genContVar :: (MonadIO m, MonadMWCRandom m, ContGen d) => d -> m Double

-- | Sample a single index from a list of weights, converting the list into
--   a distribution
sampleFrom :: (MonadIO m, MonadMWCRandom m) => [Double] -> m (Int, [Double])

-- | The class of types for which we can generate uniformly distributed
--   random variates.
--   
--   The uniform PRNG uses Marsaglia's MWC256 (also known as MWC8222)
--   multiply-with-carry generator, which has a period of 2^8222 and fares
--   well in tests of randomness. It is also extremely fast, between 2 and
--   3 times faster than the Mersenne Twister.
--   
--   <i>Note</i>: Marsaglia's PRNG is not known to be cryptographically
--   secure, so you should not use it for cryptographic operations.
class Variate a

-- | a convenience helper to reference the underlying System.Random.MWC
--   function
_uniform :: (PrimMonad m, Variate a) => Gen (PrimState m) -> m a
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.MonadMWCRandom.MWCRandT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.MonadMWCRandom.MWCRandT m)
instance Control.Monad.Trans.Class.MonadTrans Control.MonadMWCRandom.MWCRandT
instance GHC.Base.Monad m => GHC.Base.Monad (Control.MonadMWCRandom.MWCRandT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.MonadMWCRandom.MWCRandT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.MonadMWCRandom.MWCRandT m)
instance Control.MonadMWCRandom.MonadMWCRandom m => Control.MonadMWCRandom.MonadMWCRandom (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.MonadMWCRandom.MonadMWCRandom m => Control.MonadMWCRandom.MonadMWCRandom (Control.Monad.Trans.Reader.ReaderT s m)
instance (GHC.Base.Monoid w, Control.MonadMWCRandom.MonadMWCRandom m) => Control.MonadMWCRandom.MonadMWCRandom (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Control.MonadMWCRandom.MonadMWCRandom m) => Control.MonadMWCRandom.MonadMWCRandom (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.MonadMWCRandom.MonadMWCRandom GHC.Types.IO
instance GHC.Base.Monad m => Control.MonadMWCRandom.MonadMWCRandom (Control.MonadMWCRandom.MWCRandT m)
instance Control.MonadEnv.MonadEnv m s a r => Control.MonadEnv.MonadEnv (Control.MonadMWCRandom.MWCRandT m) s a r


-- | typeclass for a discrete action space, as well as helper functions
module Reinforce.Spaces.Action

-- | Mostly tags around an Enum, but includes information about the size of
--   an action space and is used in helper functions.
class (Bounded a, Enum a) => DiscreteActionSpace a where type Size a :: Nat toAction = toEnum fromAction = fromEnum where {
    type family Size a :: Nat;
}
toAction :: DiscreteActionSpace a => Int -> a
fromAction :: DiscreteActionSpace a => a -> Int

-- | one-hot encode a bounded enumerable. Doesn't care if minBound is
--   <a>or</a> 0
oneHot :: forall a. (KnownNat (Size a), DiscreteActionSpace a) => a -> R (Size a)

-- | one-hot encode a bounded enumerable
oneHot' :: forall a. (DiscreteActionSpace a) => a -> Vector Double

-- | helper function to get all actions in a discrete action space
allActions :: DiscreteActionSpace a => [a]

-- | make a uniform-random selection of an Action in a discrete action
--   space
randomChoice :: forall m a. (MonadIO m, MonadMWCRandom m, DiscreteActionSpace a) => m a


-- | re-exports of Action- and State- types.
module Reinforce.Spaces


-- | In lieu of a history monad embedded in models maintain a logger monad
--   for easily debugging environments.
module Data.Logger

-- | Our primary datatype for an event in a trace. Contains the episode
--   number, reward, state, and action taken (in that order). TODO: change
--   the ordering to <tt>Event Integer s a r</tt>
data Event r o a
Event :: Integer -> r -> o -> a -> Event r o a

-- | A logging monad, this is seperate from a History monad in that this is
--   intended to be used for debugging and for toggling log information.
--   
--   FIXME: In reality, this is halfway between commenting/uncommenting
--   print statements, and passing CPP flags. Something should be done
--   about this or a real logging Monad should be brought in.
class Monad m => Logger m

-- | log at the <a>info</a> level.
info :: Logger m => Text -> m ()

-- | log at the <a>info</a> level, appending information on the left.
info_ :: Logger m => Text -> Text -> m ()

-- | log at the <a>debug</a> level.
debug :: Logger m => Text -> m ()

-- | log at the <a>debug</a> level, appending information on the left.
debug_ :: Logger m => Text -> Text -> m ()

-- | A prebuilt type which doesn't actually log anything.
newtype NoopLogger m x
NoopLogger :: m x -> NoopLogger m x
[runNoopLogger] :: NoopLogger m x -> m x

-- | A prebuilt type that does all levels of logging
newtype DebugLogger m x
DebugLogger :: m x -> DebugLogger m x
[runDebugLogger] :: DebugLogger m x -> m x
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Data.Logger.DebugLogger m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Logger.DebugLogger m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Logger.DebugLogger m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Logger.DebugLogger m)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Logger.DebugLogger m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Data.Logger.NoopLogger m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Data.Logger.NoopLogger m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Logger.NoopLogger m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Logger.NoopLogger m)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Logger.NoopLogger m)
instance (GHC.Show.Show a, GHC.Show.Show o, GHC.Show.Show r) => GHC.Show.Show (Data.Logger.Event r o a)
instance Data.Logger.Logger m => Data.Logger.Logger (Control.Monad.Trans.State.Lazy.StateT s m)
instance Data.Logger.Logger m => Data.Logger.Logger (Control.MonadMWCRandom.MWCRandT m)
instance (Data.Logger.Logger m, GHC.Base.Monoid w) => Data.Logger.Logger (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Data.Logger.Logger Servant.Common.Req.ClientM
instance Data.Logger.Logger GHC.Types.IO
instance GHC.Base.Monad m => Data.Logger.Logger (Data.Logger.NoopLogger m)
instance Control.MonadEnv.MonadEnv m s a r => Control.MonadEnv.MonadEnv (Data.Logger.NoopLogger m) s a r
instance GHC.Base.Monad m => Data.Logger.Logger (Data.Logger.DebugLogger m)
instance Control.MonadEnv.MonadEnv m s a r => Control.MonadEnv.MonadEnv (Data.Logger.DebugLogger m) s a r


-- | Shared datatypes between Gym environments and the haskell
--   implementation of CartPole.
module Data.CartPole

-- | The state of a cart on a pole in a CartPole environment
data StateCP
StateCP :: Float -> Float -> Float -> Float -> StateCP

-- | position of the cart on the track
[position] :: StateCP -> Float

-- | angle of the pole with the vertical
[angle] :: StateCP -> Float

-- | cart velocity
[velocity] :: StateCP -> Float

-- | rate of change of the angle
[angleRate] :: StateCP -> Float

-- | Cartpole can only go left or right has an action space of "discrete 2"
--   containing {0..n-1}.
--   
--   FIXME: Migrate this to either a more generic "directions" actions
--   (would need things like "up", "down" versions as well) or a "discrete
--   actions" version. I'm a fan of the former.
data Action
GoLeft :: Action
GoRight :: Action

-- | Specific datatype for a CartPole event
type Event = Event Double StateCP Action
instance GHC.Classes.Ord Data.CartPole.StateCP
instance GHC.Generics.Generic Data.CartPole.StateCP
instance GHC.Classes.Eq Data.CartPole.StateCP
instance GHC.Show.Show Data.CartPole.StateCP
instance GHC.Generics.Generic Data.CartPole.Action
instance GHC.Classes.Ord Data.CartPole.Action
instance GHC.Enum.Bounded Data.CartPole.Action
instance GHC.Enum.Enum Data.CartPole.Action
instance GHC.Classes.Eq Data.CartPole.Action
instance GHC.Show.Show Data.CartPole.Action
instance Data.Hashable.Class.Hashable Data.CartPole.Action
instance Reinforce.Spaces.Action.DiscreteActionSpace Data.CartPole.Action
instance Data.Aeson.Types.ToJSON.ToJSON Data.CartPole.Action
instance Data.Hashable.Class.Hashable Data.CartPole.StateCP
instance GHC.Base.Monoid Data.CartPole.StateCP
instance Reinforce.Spaces.State.StateSpace Data.CartPole.StateCP
instance Data.Aeson.Types.FromJSON.FromJSON Data.CartPole.StateCP
instance Reinforce.Spaces.State.StateSpaceStatic Data.CartPole.StateCP


-- | Implementation of an n-armed bandit environment.
--   
--   FIXME: currently this is only for a 10-armed bandit. This needs to be
--   tied to a config.
module Environments.Bandits

-- | Monad for an n-armed bandit environment
newtype Environment a
Environment :: RWST Config (DList Event) () IO a -> Environment a
[getEnvironment] :: Environment a -> RWST Config (DList Event) () IO a

-- | run an n-armed bandit environment
runEnvironment :: Config -> Environment () -> IO (DList Event)

-- | Our primary datatype for an event in a trace. Contains the episode
--   number, reward, state, and action taken (in that order). TODO: change
--   the ordering to <tt>Event Integer s a r</tt>
data Event r o a
Event :: Integer -> r -> o -> a -> Event r o a

-- | The slot machine index whose arm will be pulled
data Action

-- | helper function to build a bandits config with normally-distributed
--   reward functions
mkBandits :: Int -> Int -> Float -> GenIO -> Config

-- | Give the default config of a 10-armed bandit
defaultBandits :: GenIO -> Config

-- | Convert an Int to an Action in the bandit environment. Throw if the
--   Int falls out of bounds.
mkAction :: Int -> Environment Action
instance Control.Monad.RWS.Class.MonadRWS Environments.Bandits.Config (Data.DList.DList Environments.Bandits.Event) () Environments.Bandits.Environment
instance Control.Monad.State.Class.MonadState () Environments.Bandits.Environment
instance Control.Monad.Writer.Class.MonadWriter (Data.DList.DList Environments.Bandits.Event) Environments.Bandits.Environment
instance Control.Monad.Reader.Class.MonadReader Environments.Bandits.Config Environments.Bandits.Environment
instance Control.Monad.Catch.MonadThrow Environments.Bandits.Environment
instance Control.Monad.IO.Class.MonadIO Environments.Bandits.Environment
instance GHC.Base.Monad Environments.Bandits.Environment
instance GHC.Base.Applicative Environments.Bandits.Environment
instance GHC.Base.Functor Environments.Bandits.Environment
instance GHC.Generics.Generic Environments.Bandits.Action
instance GHC.Enum.Enum Environments.Bandits.Action
instance GHC.Show.Show Environments.Bandits.Action
instance GHC.Classes.Ord Environments.Bandits.Action
instance GHC.Classes.Eq Environments.Bandits.Action
instance GHC.Enum.Bounded Environments.Bandits.Action
instance Data.Hashable.Class.Hashable Environments.Bandits.Action
instance Control.MonadMWCRandom.MonadMWCRandom Environments.Bandits.Environment
instance Control.MonadEnv.MonadEnv Environments.Bandits.Environment () Environments.Bandits.Action Control.MonadEnv.Reward


-- | <ul>
--   <li>CartPole by Sutton et al.</li>
--   </ul>
--   
--   Taken from
--   <a>https://webdocs.cs.ualberta.ca/~sutton/book/code/pole.c</a> with
--   some added insights from the OpenAI gym
--   
--   cart_and_pole: the cart and pole dynamics; given action and current
--   state, estimates next state
--   
--   cart_pole: Takes an action (0 or 1) and the current values of the four
--   state variables and updates their values by estimating the state TAU
--   seconds later.
module Environments.CartPole

-- | A cartpole environment
newtype Environment a
Environment :: RWST CartPoleConf (DList Event) CartPoleState IO a -> Environment a
[getEnvironment] :: Environment a -> RWST CartPoleConf (DList Event) CartPoleState IO a

-- | run an environment with an explicit seed
runEnvironmentWithSeed :: Environment () -> GenIO -> IO (DList Event)

-- | same as <a>runEnvironmentWithSeed</a> but don't return history
runEnvironmentWithSeed_ :: Environment () -> GenIO -> IO ()

-- | run an environment and create a new random generator for each
--   effectful action
runEnvironment :: Environment () -> IO (DList Event)

-- | same as <a>runEnvironment</a> but don't return history
runEnvironment_ :: Environment () -> IO ()

-- | Our primary datatype for an event in a trace. Contains the episode
--   number, reward, state, and action taken (in that order). TODO: change
--   the ordering to <tt>Event Integer s a r</tt>
data Event r o a
Event :: Integer -> r -> o -> a -> Event r o a

-- | Cartpole can only go left or right has an action space of "discrete 2"
--   containing {0..n-1}.
--   
--   FIXME: Migrate this to either a more generic "directions" actions
--   (would need things like "up", "down" versions as well) or a "discrete
--   actions" version. I'm a fan of the former.
data Action

-- | The state of a cart on a pole in a CartPole environment
data StateCP
instance Control.Monad.RWS.Class.MonadRWS Environments.CartPole.CartPoleConf (Data.DList.DList Data.CartPole.Event) Environments.CartPole.CartPoleState Environments.CartPole.Environment
instance Control.Monad.State.Class.MonadState Environments.CartPole.CartPoleState Environments.CartPole.Environment
instance Control.Monad.Writer.Class.MonadWriter (Data.DList.DList Data.CartPole.Event) Environments.CartPole.Environment
instance Control.Monad.Reader.Class.MonadReader Environments.CartPole.CartPoleConf Environments.CartPole.Environment
instance Control.Monad.Catch.MonadThrow Environments.CartPole.Environment
instance Control.Monad.IO.Class.MonadIO Environments.CartPole.Environment
instance GHC.Base.Monad Environments.CartPole.Environment
instance GHC.Base.Applicative Environments.CartPole.Environment
instance GHC.Base.Functor Environments.CartPole.Environment
instance GHC.Classes.Eq Environments.CartPole.CartPoleState
instance GHC.Show.Show Environments.CartPole.CartPoleState
instance Control.MonadMWCRandom.MonadMWCRandom Environments.CartPole.Environment
instance Control.MonadEnv.MonadEnv Environments.CartPole.Environment Data.CartPole.StateCP Data.CartPole.Action Control.MonadEnv.Reward


-- | Underlying implementation to run a Gym environment using the
--   <tt>gym-http-client</tt>.
module Environments.Gym.Internal

-- | The gym environment, which is shared through all openai/gym instances
newtype GymEnvironmentT s a t x
GymEnvironmentT :: RWST GymConfigs (DList (Event Reward s a)) (LastState s) (ClientT t) x -> GymEnvironmentT s a t x
[getEnvironmentT] :: GymEnvironmentT s a t x -> RWST GymConfigs (DList (Event Reward s a)) (LastState s) (ClientT t) x

-- | type alias for a runEnvironment type which executes an environment
--   action
type RunnerT s a t x = Bool -> GymEnvironmentT s a t x -> t (Either ServantError (DList (Event Reward s a)))

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | Possible errors we might encounter while interacting with our
--   environment
data GymException
UnexpectedServerResponse :: String -> GymException
TypeError :: String -> GymException
EnvironmentRequiresReset :: GymException

-- | run an effectful gym to completion and return either an error, or the
--   history of the agent. FIXME: move this into a History monad seperate
--   from the Environment so that we don't blow up memory.
runEnvironmentT :: forall o a t x. MonadIO t => GymEnv -> Manager -> BaseUrl -> Bool -> GymEnvironmentT o a t x -> t (Either ServantError (DList (Event Reward o a)))

-- | same as <a>runEnvironmentT</a>, but with IO as the base monad
runEnvironment :: GymEnv -> Manager -> BaseUrl -> Bool -> GymEnvironment o a x -> IO (Either ServantError (DList (Event Reward o a)))

-- | same as <a>runEnvironmentT</a>, however use http-client's default
--   manager settings
runDefaultEnvironmentT :: MonadIO t => GymEnv -> Bool -> GymEnvironmentT o a t x -> t (Either ServantError (DList (Event Reward o a)))

-- | same as <a>runEnvironment</a>, however use http-client's default
--   manager settings
runDefaultEnvironment :: GymEnv -> Bool -> GymEnvironment o a x -> IO (Either ServantError (DList (Event Reward o a)))

-- | generic rest function which makes a call to the gym and returns the
--   first observation
_reset :: (MonadIO t, MonadThrow t, FromJSON o) => GymEnvironmentT o a t (Initial o)

-- | generic step function which takes a ToJSONable action and returns a
--   reward and a FromJSONable state
_step :: (MonadIO t, MonadThrow t, ToJSON a, r ~ Reward, FromJSON o) => a -> GymEnvironmentT o a t (Obs r o)
instance GHC.Show.Show Environments.Gym.Internal.GymException
instance GHC.Base.Monad t => Control.Monad.RWS.Class.MonadRWS Environments.Gym.Internal.GymConfigs (Data.DList.DList (Data.Logger.Event Control.MonadEnv.Reward s a)) (Environments.Gym.Internal.LastState s) (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Monad t => Control.Monad.State.Class.MonadState (Environments.Gym.Internal.LastState s) (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Monad t => Control.Monad.Writer.Class.MonadWriter (Data.DList.DList (Data.Logger.Event Control.MonadEnv.Reward s a)) (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Monad t => Control.Monad.Reader.Class.MonadReader Environments.Gym.Internal.GymConfigs (Environments.Gym.Internal.GymEnvironmentT s a t)
instance Control.Monad.Catch.MonadThrow t => Control.Monad.Catch.MonadThrow (Environments.Gym.Internal.GymEnvironmentT s a t)
instance Control.Monad.IO.Class.MonadIO t => Control.Monad.IO.Class.MonadIO (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Monad t => GHC.Base.Monad (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Monad t => GHC.Base.Applicative (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Base.Functor t => GHC.Base.Functor (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Show.Show o => GHC.Show.Show (Environments.Gym.Internal.LastState o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Environments.Gym.Internal.LastState o)
instance Control.Monad.Catch.MonadThrow t => Control.Monad.Catch.MonadThrow (Environments.Gym.Internal.ClientT t)
instance Control.Monad.IO.Class.MonadIO t => Control.Monad.IO.Class.MonadIO (Environments.Gym.Internal.ClientT t)
instance GHC.Base.Monad t => Control.Monad.Reader.Class.MonadReader Servant.Common.Req.ClientEnv (Environments.Gym.Internal.ClientT t)
instance GHC.Base.Monad t => Control.Monad.Error.Class.MonadError Servant.Common.Req.ServantError (Environments.Gym.Internal.ClientT t)
instance GHC.Base.Monad t => GHC.Base.Monad (Environments.Gym.Internal.ClientT t)
instance GHC.Base.Monad t => GHC.Base.Applicative (Environments.Gym.Internal.ClientT t)
instance GHC.Base.Functor t => GHC.Base.Functor (Environments.Gym.Internal.ClientT t)
instance Control.Monad.Trans.Class.MonadTrans Environments.Gym.Internal.ClientT
instance Control.Monad.Trans.Class.MonadTrans (Environments.Gym.Internal.GymEnvironmentT s a)
instance (Control.Monad.IO.Class.MonadIO t, Control.MonadMWCRandom.MonadMWCRandom t) => Control.MonadMWCRandom.MonadMWCRandom (Environments.Gym.Internal.GymEnvironmentT s a t)
instance GHC.Exception.Exception Environments.Gym.Internal.GymException


-- | The inverted pendulum swingup problem is a classic problem in the
--   control literature. In this version of the problem, the pendulum
--   starts in a random position, and the goal is to swing it up so it
--   stays upright.
--   
--   <a>https://gym.openai.com/envs/Acrobot-v1</a>
module Environments.Gym.ClassicControl.AcrobotV1

-- | Acrobot Actions
data Action
RightTorque :: Action
NoTorque :: Action
LeftTorque :: Action

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | The Acrobot's State FIXME: keep semantics or move to a tuple?
data State
State :: Float -> Float -> Float -> Float -> Float -> Float -> State
[cosVel0] :: State -> Float
[sinVel0] :: State -> Float
[cosVel1] :: State -> Float
[sinVel1] :: State -> Float
[joint0Angle] :: State -> Float
[joint1Angle] :: State -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with AcrobotV1 type dependencies
type EnvironmentT t = GymEnvironmentT State Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT State Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT State Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT State Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT State Action t x
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Generics.Generic Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Classes.Eq Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Show.Show Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Classes.Ord Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Enum.Bounded Environments.Gym.ClassicControl.AcrobotV1.Action
instance GHC.Enum.Enum Environments.Gym.ClassicControl.AcrobotV1.Action
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.AcrobotV1.State
instance GHC.Classes.Ord Environments.Gym.ClassicControl.AcrobotV1.State
instance GHC.Generics.Generic Environments.Gym.ClassicControl.AcrobotV1.State
instance GHC.Classes.Eq Environments.Gym.ClassicControl.AcrobotV1.State
instance GHC.Show.Show Environments.Gym.ClassicControl.AcrobotV1.State
instance Data.Aeson.Types.FromJSON.FromJSON Environments.Gym.ClassicControl.AcrobotV1.State
instance Data.Aeson.Types.ToJSON.ToJSON Environments.Gym.ClassicControl.AcrobotV1.Action
instance (Control.Monad.IO.Class.MonadIO t, Control.Monad.Catch.MonadThrow t) => Control.MonadEnv.MonadEnv (Environments.Gym.ClassicControl.AcrobotV1.EnvironmentT t) Environments.Gym.ClassicControl.AcrobotV1.State Environments.Gym.ClassicControl.AcrobotV1.Action Control.MonadEnv.Reward


-- | Environment description: &gt; A pole is attached by an un-actuated
--   joint to a cart, which moves along a &gt; frictionless track. The
--   system is controlled by applying a force of +1 or -1 &gt; to the cart.
--   The pendulum starts upright, and the goal is to prevent it from &gt;
--   falling over. A reward of +1 is provided for every timestep that the
--   pole &gt; remains upright. The episode ends when the pole is more than
--   15 degrees from &gt; vertical, or the cart moves more than 2.4 units
--   from the center.
--   
--   <a>https://gym.openai.com/envs/CartPole-v0</a>
module Environments.Gym.ClassicControl.CartPoleV0

-- | Cartpole can only go left or right has an action space of "discrete 2"
--   containing {0..n-1}.
--   
--   FIXME: Migrate this to either a more generic "directions" actions
--   (would need things like "up", "down" versions as well) or a "discrete
--   actions" version. I'm a fan of the former.
data Action
GoLeft :: Action
GoRight :: Action

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | The state of a cart on a pole in a CartPole environment
data StateCP
StateCP :: Float -> Float -> Float -> Float -> StateCP

-- | position of the cart on the track
[position] :: StateCP -> Float

-- | angle of the pole with the vertical
[angle] :: StateCP -> Float

-- | cart velocity
[velocity] :: StateCP -> Float

-- | rate of change of the angle
[angleRate] :: StateCP -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with CartPoleV0 type dependencies
type EnvironmentT t = GymEnvironmentT StateCP Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT StateCP Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT StateCP Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT StateCP Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT StateCP Action t x
instance (Control.Monad.IO.Class.MonadIO t, Control.Monad.Catch.MonadThrow t) => Control.MonadEnv.MonadEnv (Environments.Gym.ClassicControl.CartPoleV0.EnvironmentT t) Data.CartPole.StateCP Data.CartPole.Action Control.MonadEnv.Reward


-- | Environment description: &gt; A pole is attached by an un-actuated
--   joint to a cart, which moves along a &gt; frictionless track. The
--   system is controlled by applying a force of +1 or -1 &gt; to the cart.
--   The pendulum starts upright, and the goal is to prevent it from &gt;
--   falling over. A reward of +1 is provided for every timestep that the
--   pole &gt; remains upright. The episode ends when the pole is more than
--   15 degrees from &gt; vertical, or the cart moves more than 2.4 units
--   from the center. &gt; &gt; CartPole-v1 defines "solving" as getting
--   average reward of 475.0 over 100 &gt; consecutive trials. &gt; &gt;
--   This environment corresponds to the version of the cart-pole problem
--   &gt; described by Barto, Sutton, and Anderson [Barto83].
--   
--   <a>https://gym.openai.com/envs/CartPole-v1</a>
module Environments.Gym.ClassicControl.CartPoleV1

-- | Cartpole can only go left or right has an action space of "discrete 2"
--   containing {0..n-1}.
--   
--   FIXME: Migrate this to either a more generic "directions" actions
--   (would need things like "up", "down" versions as well) or a "discrete
--   actions" version. I'm a fan of the former.
data Action
GoLeft :: Action
GoRight :: Action

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | The state of a cart on a pole in a CartPole environment
data StateCP
StateCP :: Float -> Float -> Float -> Float -> StateCP

-- | position of the cart on the track
[position] :: StateCP -> Float

-- | angle of the pole with the vertical
[angle] :: StateCP -> Float

-- | cart velocity
[velocity] :: StateCP -> Float

-- | rate of change of the angle
[angleRate] :: StateCP -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with CartPoleV0 type dependencies
type EnvironmentT t = GymEnvironmentT StateCP Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT StateCP Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT StateCP Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT StateCP Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT StateCP Action t x


-- | Environment description: &gt; A car is on a one-dimensional track,
--   positioned between two "mountains". &gt; The goal is to drive up the
--   mountain on the right; however, the car's &gt; engine is not strong
--   enough to scale the mountain in a single pass. &gt; Therefore, the
--   only way to succeed is to drive back and forth to build up &gt;
--   momentum. &gt; &gt; MountainCar-v0 defines "solving" as getting
--   average reward of -110.0 over &gt; 100 consecutive trials. &gt; &gt;
--   This problem was first described by Andrew Moore in his PhD thesis
--   &gt; [Moore90].
--   
--   <a>https://gym.openai.com/envs/MountainCar-v0</a>
module Environments.Gym.ClassicControl.MountainCarV0

-- | Actions a car can perform to get out of it's predicament
data Action
MoveLeft :: Action
DoNothing :: Action
MoveRight :: Action

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | State of a car stuck between two hills
data State
State :: Float -> Float -> State
[position] :: State -> Float
[velocity] :: State -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with MountainCarV0 type dependencies
type EnvironmentT t = GymEnvironmentT State Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT State Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT State Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT State Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT State Action t x
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Generics.Generic Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Classes.Eq Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Show.Show Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Classes.Ord Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Enum.Bounded Environments.Gym.ClassicControl.MountainCarV0.Action
instance GHC.Enum.Enum Environments.Gym.ClassicControl.MountainCarV0.Action
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.MountainCarV0.State
instance GHC.Classes.Ord Environments.Gym.ClassicControl.MountainCarV0.State
instance GHC.Generics.Generic Environments.Gym.ClassicControl.MountainCarV0.State
instance GHC.Classes.Eq Environments.Gym.ClassicControl.MountainCarV0.State
instance GHC.Show.Show Environments.Gym.ClassicControl.MountainCarV0.State
instance Data.Aeson.Types.FromJSON.FromJSON Environments.Gym.ClassicControl.MountainCarV0.State
instance Data.Aeson.Types.ToJSON.ToJSON Environments.Gym.ClassicControl.MountainCarV0.Action
instance (Control.Monad.Catch.MonadThrow t, Control.Monad.IO.Class.MonadIO t) => Control.MonadEnv.MonadEnv (Environments.Gym.ClassicControl.MountainCarV0.EnvironmentT t) Environments.Gym.ClassicControl.MountainCarV0.State Environments.Gym.ClassicControl.MountainCarV0.Action Control.MonadEnv.Reward


-- | Environment description: &gt; A car is on a one-dimensional track,
--   positioned between two "mountains". &gt; The goal is to drive up the
--   mountain on the right; however, the car's &gt; engine is not strong
--   enough to scale the mountain in a single pass. &gt; Therefore, the
--   only way to succeed is to drive back and forth to build up &gt;
--   momentum. Here, the reward is greater if you spend less energy to
--   reach the &gt; goal. &gt; &gt; MountainCarContinuous-v0 defines
--   "solving" as getting average reward of &gt; 90.0 over 100 consecutive
--   trials. &gt; &gt; This problem was first described by Andrew Moore in
--   his PhD thesis [Moore90]. &gt; &gt; Here, this is the continuous
--   version.
--   
--   <a>https://gym.openai.com/envs/MountainCarContinuous-v0</a>
module Environments.Gym.ClassicControl.MountainCarContinuousV0

-- | Actions a car can perform to get out of it's predicament
data Action
MoveLeft :: Action
DoNothing :: Action
MoveRight :: Action

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | State of a car stuck between two hills
data State
State :: Float -> Float -> State
[position] :: State -> Float
[velocity] :: State -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with MountainCarV0 type dependencies
type EnvironmentT t = GymEnvironmentT State Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT State Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT State Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT State Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT State Action t x


-- | The inverted pendulum swingup problem is a classic problem in the
--   control literature. In this version of the problem, the pendulum
--   starts in a random position, and the goal is to swing it up so it
--   stays upright.
--   
--   <a>https://gym.openai.com/envs/Pendulum-v0</a>
module Environments.Gym.ClassicControl.PendulumV0

-- | Force to exert on the pendulum
newtype Action
Action :: Float -> Action
[getAction] :: Action -> Float

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | State of a PendulumV0 environment FIXME: give these semantics or move
--   to a tuple?
data State
State :: Float -> Float -> Float -> State
[cosTheta] :: State -> Float
[sinTheta] :: State -> Float
[thetaDot] :: State -> Float

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with PendulumV0 type dependencies
type EnvironmentT t = GymEnvironmentT State Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT State Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT State Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT State Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT State Action t x
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.PendulumV0.Action
instance GHC.Generics.Generic Environments.Gym.ClassicControl.PendulumV0.Action
instance GHC.Classes.Eq Environments.Gym.ClassicControl.PendulumV0.Action
instance GHC.Show.Show Environments.Gym.ClassicControl.PendulumV0.Action
instance GHC.Classes.Ord Environments.Gym.ClassicControl.PendulumV0.Action
instance Data.Hashable.Class.Hashable Environments.Gym.ClassicControl.PendulumV0.State
instance GHC.Classes.Ord Environments.Gym.ClassicControl.PendulumV0.State
instance GHC.Generics.Generic Environments.Gym.ClassicControl.PendulumV0.State
instance GHC.Classes.Eq Environments.Gym.ClassicControl.PendulumV0.State
instance GHC.Show.Show Environments.Gym.ClassicControl.PendulumV0.State
instance Data.Aeson.Types.FromJSON.FromJSON Environments.Gym.ClassicControl.PendulumV0.State
instance Data.Aeson.Types.ToJSON.ToJSON Environments.Gym.ClassicControl.PendulumV0.Action
instance (Control.Monad.IO.Class.MonadIO t, Control.Monad.Catch.MonadThrow t) => Control.MonadEnv.MonadEnv (Environments.Gym.ClassicControl.PendulumV0.EnvironmentT t) Environments.Gym.ClassicControl.PendulumV0.State Environments.Gym.ClassicControl.PendulumV0.Action Control.MonadEnv.Reward


-- | The agent controls the movement of a character in a grid world. Some
--   tiles of the grid are walkable, and others lead to the agent falling
--   into the water. Additionally, the movement direction of the agent is
--   uncertain and only partially depends on the chosen direction. The
--   agent is rewarded for finding a walkable path to a goal tile.
--   
--   <a>https://gym.openai.com/envs/FrozenLake-v0</a>
module Environments.Gym.ToyText.FrozenLakeV0

-- | type alias of <a>RunnerT</a> in IO
type Runner s a x = RunnerT s a IO x

-- | The current position of the agent on the frozen lake
newtype StateFL
Position :: Int -> StateFL
[unPosition] :: StateFL -> Int

-- | Convert <a>StateFL</a> to a computable type
toVector :: StateFL -> Vector Int

-- | Build a FrozenLakeV0 state, throwing if the position is out of bounds.
mkStateFL :: MonadThrow m => Int -> m StateFL

-- | Alias to <a>EnvironmentT</a> in IO
type Environment = EnvironmentT IO

-- | Alias to <a>GymEnvironmentT</a> with FrozenLakeV0 type dependencies
type EnvironmentT t = GymEnvironmentT StateFL Action t

-- | Alias to <a>runEnvironment</a> in IO
runEnvironment :: Manager -> BaseUrl -> RunnerT StateFL Action IO x

-- | Alias to <a>runEnvironmentT</a>
runEnvironmentT :: MonadIO t => Manager -> BaseUrl -> RunnerT StateFL Action t x

-- | Alias to <a>runDefaultEnvironment</a> in IO
runDefaultEnvironment :: RunnerT StateFL Action IO x

-- | Alias to <a>runDefaultEnvironmentT</a>
runDefaultEnvironmentT :: MonadIO t => RunnerT StateFL Action t x

-- | Actions that can be performed in FrozenLakeV0
data Action
Left :: Action
Down :: Action
Right :: Action
Up :: Action
instance Data.Hashable.Class.Hashable Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Generics.Generic Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Classes.Eq Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Show.Show Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Classes.Ord Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Enum.Bounded Environments.Gym.ToyText.FrozenLakeV0.Action
instance GHC.Enum.Enum Environments.Gym.ToyText.FrozenLakeV0.Action
instance Data.Hashable.Class.Hashable Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance GHC.Classes.Ord Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance GHC.Generics.Generic Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance GHC.Classes.Eq Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance GHC.Show.Show Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance Data.Aeson.Types.FromJSON.FromJSON Environments.Gym.ToyText.FrozenLakeV0.StateFL
instance Data.Aeson.Types.ToJSON.ToJSON Environments.Gym.ToyText.FrozenLakeV0.Action
instance (Control.Monad.Catch.MonadThrow t, Control.Monad.IO.Class.MonadIO t) => Control.MonadEnv.MonadEnv (Environments.Gym.ToyText.FrozenLakeV0.EnvironmentT t) Environments.Gym.ToyText.FrozenLakeV0.StateFL Environments.Gym.ToyText.FrozenLakeV0.Action Control.MonadEnv.Reward
